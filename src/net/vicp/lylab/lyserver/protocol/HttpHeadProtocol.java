package net.vicp.lylab.lyserver.protocol;

import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import net.vicp.lylab.core.CoreDef;
import net.vicp.lylab.core.NonCloneableBaseObject;
import net.vicp.lylab.core.exceptions.LYException;
import net.vicp.lylab.core.interfaces.Protocol;
import net.vicp.lylab.core.model.Pair;
import net.vicp.lylab.utils.Algorithm;
import net.vicp.lylab.utils.Utils;

public class HttpHeadProtocol extends NonCloneableBaseObject implements Protocol {

	static byte[] test = new byte[] {
			  0x4e ,0x4f ,0x54 ,0x49 ,0x46 ,0x59 ,0x20 ,0x2a ,0x20 ,0x48 ,0x54 ,0x54 ,0x50 ,0x2f ,0x31 ,0x2e
			 ,0x31 ,0x0d ,0x0a ,0x48 ,0x4f ,0x53 ,0x54 ,0x3a ,0x20 ,0x32 ,0x33 ,0x39 ,0x2e ,0x32 ,0x35 ,0x35
			 ,0x2e ,0x32 ,0x35 ,0x35 ,0x2e ,0x32 ,0x35 ,0x30 ,0x3a ,0x31 ,0x39 ,0x30 ,0x30 ,0x0d ,0x0a ,0x43
			 ,0x41 ,0x43 ,0x48 ,0x45 ,0x2d ,0x43 ,0x4f ,0x4e ,0x54 ,0x52 ,0x4f ,0x4c ,0x3a ,0x20 ,0x6d ,0x61
			 ,0x78 ,0x2d ,0x61 ,0x67 ,0x65 ,0x3d ,0x31 ,0x30 ,0x30 ,0x0d ,0x0a ,0x4c ,0x4f ,0x43 ,0x41 ,0x54
			 ,0x49 ,0x4f ,0x4e ,0x3a ,0x20 ,0x68 ,0x74 ,0x74 ,0x70 ,0x3a ,0x2f ,0x2f ,0x31 ,0x39 ,0x32 ,0x2e
			 ,0x31 ,0x36 ,0x38 ,0x2e ,0x33 ,0x2e ,0x32 ,0x30 ,0x33 ,0x3a ,0x31 ,0x39 ,0x30 ,0x30 ,0x2f ,0x69
			 ,0x67 ,0x64 ,0x2e ,0x78 ,0x6d ,0x6c ,0x0d ,0x0a ,0x4e ,0x54 ,0x3a ,0x20 ,0x75 ,0x72 ,0x6e ,0x3a
			 ,0x73 ,0x63 ,0x68 ,0x65 ,0x6d ,0x61 ,0x73 ,0x2d ,0x75 ,0x70 ,0x6e ,0x70 ,0x2d ,0x6f ,0x72 ,0x67
			 ,0x3a ,0x64 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65 ,0x3a ,0x57 ,0x41 ,0x4e ,0x43 ,0x6f ,0x6e ,0x6e ,0x65
			 ,0x63 ,0x74 ,0x69 ,0x6f ,0x6e ,0x44 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65 ,0x3a ,0x31 ,0x0d ,0x0a ,0x4e
			 ,0x54 ,0x53 ,0x3a ,0x20 ,0x73 ,0x73 ,0x64 ,0x70 ,0x3a ,0x61 ,0x6c ,0x69 ,0x76 ,0x65 ,0x0d ,0x0a
			 ,0x53 ,0x45 ,0x52 ,0x56 ,0x45 ,0x52 ,0x3a ,0x20 ,0x69 ,0x70 ,0x6f ,0x73 ,0x2f ,0x37 ,0x2e ,0x30
			 ,0x20 ,0x55 ,0x50 ,0x6e ,0x50 ,0x2f ,0x31 ,0x2e ,0x30 ,0x20 ,0x54 ,0x4c ,0x2d ,0x57 ,0x52 ,0x39
			 ,0x34 ,0x31 ,0x4e ,0x2f ,0x57 ,0x52 ,0x39 ,0x34 ,0x31 ,0x76 ,0x37 ,0x0d ,0x0a ,0x55 ,0x53 ,0x4e
			 ,0x3a ,0x20 ,0x75 ,0x75 ,0x69 ,0x64 ,0x3a ,0x39 ,0x66 ,0x30 ,0x38 ,0x36 ,0x35 ,0x62 ,0x33 ,0x2d
			 ,0x66 ,0x35 ,0x64 ,0x61 ,0x2d ,0x34 ,0x61 ,0x64 ,0x35 ,0x2d ,0x38 ,0x35 ,0x62 ,0x37 ,0x2d ,0x37
			 ,0x34 ,0x30 ,0x34 ,0x36 ,0x33 ,0x37 ,0x66 ,0x64 ,0x66 ,0x33 ,0x37 ,0x3a ,0x3a ,0x75 ,0x72 ,0x6e
			 ,0x3a ,0x73 ,0x63 ,0x68 ,0x65 ,0x6d ,0x61 ,0x73 ,0x2d ,0x75 ,0x70 ,0x6e ,0x70 ,0x2d ,0x6f ,0x72
			 ,0x67 ,0x3a ,0x64 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65 ,0x3a ,0x57 ,0x41 ,0x4e ,0x43 ,0x6f ,0x6e ,0x6e
			 ,0x65 ,0x63 ,0x74 ,0x69 ,0x6f ,0x6e ,0x44 ,0x65 ,0x76 ,0x69 ,0x63 ,0x65 ,0x3a ,0x31 ,0x0d ,0x0a
			 ,0x0d ,0x0a };
	
	public static void main(String[] arg)
	{
		System.out.println(Arrays.deepToString("TRACE HTTP://localhost HTTP/1.0".split("^[^:\\s]*:{1,1}")));
		Protocol p = new HttpHeadProtocol();
		System.out.println("tLeng:\t\t" + test.length);
		System.out.println("valid:\t\t" + p.validate(test, test.length));
		HttpRequestHead o = (HttpRequestHead) p.decode(test);
		System.out.println("HOST:\t\t" + o.getHead("host"));
		o.addHead("hOsT", "neW hIOst");
		System.out.println("HOST:\t\t" + o.getHead("host"));
		System.out.println("decode:\t\t" + o);
		System.out.println("encode:\n" + new String(p.encode(o)));
	}
	
	static final byte[] head = new byte[] { };
	
	static String[] headFilters = null;
	{
		try {
			headFilters = CoreDef.config.getConfig("ServerConfig").getArray("headFilters", String[].class);
		} catch (Exception e) {
			log.error(Utils.getStringFromException(e));
		}
	}
	
	@Override
	public byte[] getHead() {
		return head;
	}

	@Override
	public byte[] encode(Object obj) {
		if(obj instanceof HttpRequestHead)
		{
			List<Pair<String, String>> pairs = ((HttpRequestHead) obj).getAllHead();
			StringBuilder head = new StringBuilder();
			for(Pair<String, String> pair: pairs) {
				if(pair.getRight() == null)
					head.append(pair.getLeft() + new String(HttpRequestHead.spliter));
				else
					head.append(pair.getLeft() +":" + pair.getRight() + new String(HttpRequestHead.spliter));
			}
			head.append(new String(HttpRequestHead.spliter));
			return head.toString().getBytes();
		}
		else
			return head;
	}

	@Override
	public Object decode(byte[] bytes) {
		return decode(bytes, 0);
	}

	@Override
	public Object decode(byte[] bytes, int offset) {
		int last = offset, next = 0;
		String[] pairs;
		String key, value, raw;
		HttpRequestHead httpRequest = new HttpRequestHead();
		while (true) {
			next = Algorithm.KMPSearch(bytes, HttpRequestHead.spliter, last) + last;
			raw = new String(bytes, last, next - last);
			if(StringUtils.isBlank(raw))
				break;
			pairs = raw.split("^[^:\\s]*:{1,1}");
			if (pairs.length == 1) {
				if (!raw.contains("HTTP"))
					throw new LYException("No \"HTTP\" was found in head:-->{" + raw + "}<--");
				httpRequest.addHead(raw.trim(), null);
			} else {
				key = raw.split(":")[0];
				if (!Utils.inList(headFilters, key)) {
					value = pairs[1];
					httpRequest.addHead(key.trim(), value.trim());
				}
			}
			last = next + 2;
		}
		return httpRequest;
	}

	@Override
	public int validate(byte[] bytes, int len) {
		return validate(bytes, 0, len);
	}

	@Override
	public int validate(byte[] bytes, int offset, int len) {
		int pos = Algorithm.KMPSearch(bytes, HttpRequestHead.doubleSpliter, offset);
		if (pos > 0)
			return pos + HttpRequestHead.doubleSpliter.length;
		else
			return -1;
	}

}
